# 前置知识

导致有格式化字符串漏洞的函数有

- printf系列函数
  - printf()
  - fprintf()
  - sprintf()
  - snprintf()
- syslog()
- vprintf系列函数
- 错误日志函数
- 远程日志记录器

首先会读取到一段字符串，然后在输出函数中，没有正确的进行格式化字符串处理，导致可以读取内存的数据，写入数据等字符串的输入权交给用户就会有问题了

格式化字符串可以用来

- 读取任意地址
- 任意地址写：改返回地址，改got表，改one_gadget，改malloc_hook，改iofile

```c
char a[100];
scanf("%s",a);
printf(a);
read(0,buf,20u);
printf(buf); //这个就是一个明显的格式化字符漏洞
return 0;
//常用的格式化
printf("%x");	//输出十六进制数，没有0x
printf("%p");	//输出十六进制，带有0x
printf("abcd%n")	//将%n前面字符串abcd的长度4写入在后面
  
%10$n	//对第10个参数里面的地址修改
%100c%10$n	//对第10个参数里面的地址修改成100(0x64)
n表示，四个字节
hn表示，两个字节
hhn表示，一个字节
```

# 利用原理

## 32位

```
32位靠栈传递参数，esp地址的下一个地址开始
```



## 64位

```python
64位传递参数rdi，rsi，rdx，rcx，r8，r9，然后到栈里面esp下一个地址才是第7个参数
先利用漏洞，泄露出ebp的地址，再通过偏移算出要修改的地址，然后要修改的地址加入到payload

payload = '%10$n%11$n%12$n%13$n' +p64(0x7fffffffdd68)	#因为p64()会补全00007fffffffdd68，在遇到print的时候，会遇到00截停，所有地址要放在payload后面，有时候前面的也要对齐8字节
fmstr_payload()函数
```

